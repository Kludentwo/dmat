\chapter{Implementation}
\section{Considerations}
\subsection{Built-in functions}
Sin()\\
Xcorr\\
\subsection{Output}
\textbf{Sound and Decimation}:\\

UART\\
\section{Blackfin Setup}
\subsection{DMA}
The DMA is setup using SPI on the blackfin. We have used code from the example project "Audio Talk-Through" Which initiates the dma channels 1, 2 and 5 for input, output and moving data to the built in audio codec. The DMA has the following init parts:
\begin{lstlisting}[language=C]
*pDMA1_PERIPHERAL_MAP // What to map the DMA to.
*pDMA1_CONFIG // which configuration your want.
*pDMA1_START_ADDR // Start address of the buffer.
*pDMA1_X_COUNT // Number of transfers
*pDMA1_X_MODIFY // Number of bytes between each transfer
\end{lstlisting}
In our setup we are using 32 bytes so the DMA in- and output are set to 32 bytes, 8 bursts of 4 bytes at a time. We map the in and output dma channels to Sport0 Rx and Tx. Sport0 is connected to our physical ports described below. The last thing we have to do is enable the DMA channels and that is done with the \begin{quote}
"DMAEN"
\end{quote}  flag in the 
\begin{quote}
"pDMA1\_CONFIG"
\end{quote}
.\\
\section{Important code descriptions}
Input/output ISR\\
\textbf{Main.c}:\\
\begin{lstlisting}[language=C]
// Calculation of Delay
for(myCount = 0; myCount < SAMPLES; myCount++)
{
	if(corr[myCount] > maxNum)
	{
		maxNum = corr[myCount];
		place = myCount;	
	}
// Conversion from samples to distance
	if(myCount == (SAMPLES - 1))
	{
		time = (place*100)/fs;
		dist = (time * velocity)/200;
	}
}
// 10 times averaging
if(numDist < 10){
	totaldist += dist;
	numDist++;
}
else
{
	totaldist = totaldist/10;
	sound_factor = totaldist/20;
	totaldist = 0;
	numDist = 0;
}
// Set flags to begin distance measurements
num1 = 0;
playFlag = 1;
recFlag = 1;
\end{lstlisting}


\textbf{Processdata.c}:\\
\begin{lstlisting}[language=C]
// playing sound part
if(num1>OUTPUTLEN){
	playFlag = 0;
}
if(playFlag){
	yn = (sound[num1] << 2);
	iChannel0LeftOut = (yn << 16);
		
}
// recording part
if(num1>INPUTLEN){
	recFlag = 0;
}
if(recFlag)
{
	soundIn[num1] = (short)(iChannel0LeftIn >> 14);
}
num1++;
if(num1>5000){
	doX = 1; // Start crosscorrelation-flag
}
// generate output sound
num2 = num2 + 10 + sound_factor;//Soundfactor is the distance in 
				//  1/10 meter
num2 = num2 % 2000;	// because the sinus buffer is 2000 samples
			// we want the remainder of 2000 because 
			// maybe num2 become more then just 1 more 
			// the 2000 and we want the sinus to flow
xn = sinus[num2];			
iChannel0RightOut = (xn << 16);
\end{lstlisting}
\section{Signal/datatypes}
\section{Our Xcorr}
Description\\
Implementation\\