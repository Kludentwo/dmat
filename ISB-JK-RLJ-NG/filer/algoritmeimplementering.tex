\chapter{Implementation}
This section will describe the most important parts of our implemenation and our considerations behind this implemenation.\\
\section{Considerations}
\subsection{Built-in functions}
\begin{lstlisting}[language=C]
short sin_fr32(short x);\\
\end{lstlisting}
The built-in sin function takes in a value x, which represents time or to be more exact the length on the x-axis. So for example for x=3.1415 the output will be ~0. It returns the value on the y axis. To use the function properly you need to calculate the value in each quandrant of the unit circle. In the documentation in VisualDSP++ it is described how to calculate this. We decided not to use this function since we figured a lot of math was involved which would slow our system.

\begin{lstlisting}[language=C]
void crosscorr_fr32 (	const short    samples_x[ ], 
                     	const short    samples_y[ ],
                     	int            sample_length,
                     	int            lags,
                     	short          correlation[ ]);
\end{lstlisting}
The built-in cross correlation function takes in the two signals, in our case the output array, and the recorded array. Sample\_length is the length of the input arrays, and lags is the number of elements in the array for the cross correlation, correlation[].\\
The function is extremely easy to get going with and very simple to use. Although it can take a long time to process large arrays, so it doesn't scale very well.\\
\subsection{Output}
\textbf{Sound and Decimation}:\\
The output sound is generated via. decimation and the fact that the system constantly outputs samples with 48kHz.\\
In matlab we generated a signal of one period with 2000 samples. Running through this one at a time once every 1/48kHz would make an output frequency of: $\frac{48000Hz}{2000}=24Hz$. This is a very low frequent sound so we needed to step faster through this period. A step of 30 each time would give an output frequency of $\frac{48000Hz}{\frac{2000}{30}}=720Hz$. We figured this was nice for a distance of 0mm. Our calculation of distance returnes the distance in mm and since we measure around 3m it would be way to large, since a step of 3030 would go more then through the array with the period making some aliasing problems. We choose to convert the distance from mm til decimeters. This means we go from steps of 30 to steps of 60, making the highest frequency $\frac{48000Hz}{\frac{2000}{30}}=1440Hz$. The frequencies are very distinguishable and also pleasant to hear.\\
UART\\
\subsection{Buffer sizes}

\subsection{Output frequency}
\section{Blackfin Setup}
\subsection{DMA}
The DMA is setup using SPI on the blackfin. We have used code from the example project "Audio Talk-Through" Which initiates the dma channels 1, 2 and 5 for input, output and moving data to the built in audio codec. The DMA has the following init parts:
\begin{lstlisting}[language=C]
*pDMA1_PERIPHERAL_MAP // What to map the DMA to.
*pDMA1_CONFIG // which configuration your want.
*pDMA1_START_ADDR // Start address of the buffer.
*pDMA1_X_COUNT // Number of transfers
*pDMA1_X_MODIFY // Number of bytes between each transfer
\end{lstlisting}
In our setup we are using 32 bytes so the DMA in- and output are set to 32 bytes, 8 bursts of 4 bytes at a time. We map the in and output dma channels to Sport0 Rx and Tx. Sport0 is connected to our physical ports described below. The last thing we have to do is enable the DMA channels and that is done with the \begin{quote}
"DMAEN" flag in the "pDMA1\_CONFIG".
\end{quote}
\subsection{Sport0}
The Sport0 is set up using the table \ref{table:Sport0}
\begin{table}[htbp]
    \begin{tabular}{| p{1.5cm} | l | p{4.5cm} | p{4.5cm} |}
    \hline
    C++ def      & Comment                   & Clear bit to 0                                   & Set bit to 1                             \\ \hline
    TFSR RFSR   & Frame sync required 		 & Does not require frame sync for every word & Requires frame  					sync for every word \\ \hline
    ITFS IRFS   & Internal frame  					sync & Use external  					frame sync                    & Use internal  					frame sync            \\ \hline
    ITCLK IRCLK & Internal clock            & Use external  					clock                         & Use internal  					clock                 \\ \hline
    TSPEN RSPEN & Enable                    & Disable transmit  					or receive                & Enable transmit  					or receive         \\ \hline
    \end{tabular}
    \caption{Sport0 Initialization}
    \label{table:Sport0}
\end{table}
Our Sport0 is set up the same way as the "talkthrough" project with: "External CLK, External Frame sync, MSB first". MSB first is instantiated by writing SLEN$\_$32 to the second register. Lastly we enable it by writing "TSPEN" and "RSPEN" to the registers pSPORT0 TCR1 and RCR1.
\subsection{Interrupts}
Interrups are set up using the 4 registers SIC$\_$IAR0 to 2 and SIC$\_$IMASK. We want to use DMA1 (Sport0 RX) Interrupt so we set the second word of the SIC$\_$IAR1 to 2. We also have to register ISR handlers to Sport0 and then enable interrupt. The interrupt code will then be:
\begin{lstlisting}[language=C]
*pSIC_IAR0 = 0xffffffff;
*pSIC_IAR1 = 0xffffff2f; // DMA1 (Sport0 RX)
*pSIC_IAR2 = 0xffffffff;

register_handler(ik_ivg9, Sport0_RX_ISR); //Handler

*pSIC_IMASK = 0x00000200; // enable interrupt
\end{lstlisting}
\section{Important code descriptions}
\textbf{Defines:}\\


\textbf{calc$\_$dist}:\\
\begin{lstlisting}[language=C]
int time = 0;
int fs = 48;
int velocity = 340;
int dist = 0;
int totaldist = 0;
int numDist = 0;
int sound_factor=0;
int avg = 10;
int place = 0;
int myCount = 0;
int maxNum = 0;
int olddist = 0;
//filter coeficients:
float alpha = 0.3;

int calc_dist(short* corr){
	maxNum = 0;
            
	for(myCount = 0; myCount < SAMPLES; myCount++)
	{
		if(corr[myCount] > maxNum)
		{
			maxNum = corr[myCount];
			place = myCount;	
		}
		if(myCount == (SAMPLES - 1))
		{
			time = (place*100)/fs;
			dist = (1.096*(time * velocity)/200)-425;
		}
	}
	//average distance:
	olddist = totaldist;
	totaldist = dist*alpha + olddist*(1-alpha);
	
	sound_factor = totaldist/100;
	return totaldist;	
}
\end{lstlisting}
\textbf{Discription of calc$\_$dist function:}\\

\textbf{Process$\_$Data}:\\
\begin{lstlisting}[language=C]
void Process_Data(void)
{
	// Output Del
	if(num1>OUTPUTLEN){
		playFlag = 0;
	}
	if(playFlag){
		yn = (sound[num1] << 2);
		iChannel0LeftOut = (yn << 16);
			
	}
	
	if(num1>INPUTLEN){
		recFlag = 0;
	}
	if(recFlag)
	{
		soundIn[num1] = (short)(iChannel0LeftIn >> 14);
	}
	num1++;
	num2 = num2 + 20 + sound_factor; //Soundfactor is the distance in 1/10 meter
	num2 = num2 % 2000; 	// because the sinus buffer is 2000 samples
				// we want the remainder of 2000
				//because maybe num2 become more 
				//then just 1 more the 2000 
				//and we want the sinus to flow
	
	if(num1>5000){
		doX = 1;
	}
	xn = sinus[num2];
	
	iChannel0RightOut = (xn << 16);
}
\end{lstlisting}
\section{Signal/datatypes}
\section{Our Xcorr}
Description\\
Implementation\\